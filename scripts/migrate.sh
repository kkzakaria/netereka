#!/usr/bin/env bash
set -euo pipefail

# D1 Migration Runner (Drizzle-managed)
# Reads migrations from drizzle/*.sql (generated by drizzle-kit).
# Tracks applied migrations in _drizzle_migrations table.
# On first run against an existing DB, marks only the baseline as applied
# so that incremental migrations run.
# Default target: --remote. Pass --local for local development.
# Usage: bash scripts/migrate.sh [--local|--remote]
#
# WARNING: This script is not safe for concurrent execution against the same
# database. Rely on deploy.yml concurrency group to prevent parallel runs.

DB_NAME="netereka-db"
MIGRATIONS_DIR="drizzle"
TRACKING_TABLE="_drizzle_migrations"
BASELINE_FILE="0000_0000_baseline.sql"
TARGET="${1:---remote}"

if [[ "$TARGET" != "--local" && "$TARGET" != "--remote" ]]; then
  echo "Usage: bash scripts/migrate.sh [--local|--remote]"
  exit 1
fi

# Validate required env vars for remote mode
if [[ "$TARGET" == "--remote" ]]; then
  if [[ -z "${CLOUDFLARE_API_TOKEN:-}" ]]; then
    echo "ERROR: CLOUDFLARE_API_TOKEN is not set. Required for --remote migrations."
    exit 1
  fi
  if [[ -z "${CLOUDFLARE_ACCOUNT_ID:-}" ]]; then
    echo "ERROR: CLOUDFLARE_ACCOUNT_ID is not set. Required for --remote migrations."
    exit 1
  fi
fi

echo "==> Running migrations ($TARGET) on $DB_NAME"

# Helper: run a D1 query and parse JSON results safely.
# Returns the node script's stdout. Exits with a clear error on failure.
d1_query_json() {
  local description="$1"
  local sql="$2"
  local raw
  raw=$(npx wrangler d1 execute "$DB_NAME" "$TARGET" --command "$sql" --json) || {
    echo "ERROR: wrangler d1 execute failed during: $description"
    exit 1
  }
  echo "$raw" | node -e "
    const raw = require('fs').readFileSync(0,'utf8');
    try {
      const parsed = JSON.parse(raw);
      if (!parsed[0] || !parsed[0].results) {
        console.error('ERROR: Unexpected wrangler response during: $description');
        console.error('Raw output (first 500 chars):', raw.slice(0, 500));
        process.exit(1);
      }
      console.log(JSON.stringify(parsed[0].results));
    } catch (e) {
      console.error('ERROR: Failed to parse wrangler JSON during: $description');
      console.error('Parse error:', e.message);
      console.error('Raw output (first 500 chars):', raw.slice(0, 500));
      process.exit(1);
    }
  " || {
    echo "ERROR: JSON parsing failed during: $description"
    exit 1
  }
}

# 1. Ensure tracking table exists
npx wrangler d1 execute "$DB_NAME" "$TARGET" --command \
  "CREATE TABLE IF NOT EXISTS $TRACKING_TABLE (
    filename TEXT PRIMARY KEY,
    applied_at TEXT NOT NULL DEFAULT (datetime('now'))
  );"

# 2. Get list of already-applied migrations
APPLIED_JSON=$(d1_query_json "query applied migrations" \
  "SELECT filename FROM $TRACKING_TABLE ORDER BY filename;")
APPLIED=$(echo "$APPLIED_JSON" | node -p "JSON.parse(require('fs').readFileSync(0,'utf8')).map(r=>r.filename).join('\n')")

# 3. Collect migration files (*.sql at root of drizzle/ only; glob does not descend into meta/)
if [[ ! -d "$MIGRATIONS_DIR" ]]; then
  echo "ERROR: Migrations directory not found: $MIGRATIONS_DIR"
  echo "Working directory: $(pwd)"
  exit 1
fi

shopt -s nullglob
MIGRATION_FILES=("$MIGRATIONS_DIR"/*.sql)
shopt -u nullglob

if [[ ${#MIGRATION_FILES[@]} -eq 0 ]]; then
  echo "==> No migration files found in $MIGRATIONS_DIR"
  exit 0
fi

# Helper: validate migration filename contains only safe characters
validate_filename() {
  local fname="$1"
  if [[ ! "$fname" =~ ^[0-9a-zA-Z_.-]+\.sql$ ]]; then
    echo "ERROR: Invalid migration filename: $fname"
    exit 1
  fi
}

# 4. Bootstrap: if tracking is empty but DB already has tables,
#    mark ONLY the baseline as applied (so incremental migrations run).
#    Ignores underscore-prefixed tables (e.g., _drizzle_migrations itself).
if [[ -z "$APPLIED" ]]; then
  HAS_TABLES_JSON=$(d1_query_json "check for existing tables" \
    "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE '\_%' ESCAPE '\\' LIMIT 1;")
  HAS_TABLES=$(echo "$HAS_TABLES_JSON" | node -p "JSON.parse(require('fs').readFileSync(0,'utf8')).length > 0 ? 'yes' : 'no'")

  if [[ "$HAS_TABLES" != "yes" && "$HAS_TABLES" != "no" ]]; then
    echo "ERROR: Unexpected HAS_TABLES value: '$HAS_TABLES'"
    echo "Expected 'yes' or 'no' from sqlite_master query."
    exit 1
  fi

  if [[ "$HAS_TABLES" == "yes" ]]; then
    # Verify baseline file exists before recording it
    if [[ ! -f "$MIGRATIONS_DIR/$BASELINE_FILE" ]]; then
      echo "ERROR: Baseline file not found: $MIGRATIONS_DIR/$BASELINE_FILE"
      echo "Cannot bootstrap migration tracking for existing database."
      echo "Ensure the baseline migration file exists and BASELINE_FILE is correct."
      exit 1
    fi
    echo "==> Bootstrap: existing DB detected, marking baseline as applied"
    validate_filename "$BASELINE_FILE"
    npx wrangler d1 execute "$DB_NAME" "$TARGET" --command \
      "INSERT OR IGNORE INTO $TRACKING_TABLE (filename) VALUES ('$BASELINE_FILE');"
    echo "    Recorded: $BASELINE_FILE"
    APPLIED="$BASELINE_FILE"
    echo "==> Bootstrap complete â€” incremental migrations will now run"
  fi
fi

# 5. Run pending migrations
PENDING=0
TMPDIR_MIGRATE=$(mktemp -d)
trap "rm -rf '$TMPDIR_MIGRATE'" EXIT

for file in "${MIGRATION_FILES[@]}"; do
  fname=$(basename "$file")
  validate_filename "$fname"

  if [[ -n "$APPLIED" ]] && echo "$APPLIED" | grep -qxF "$fname"; then
    continue
  fi

  echo "==> Applying: $fname"
  # Combine migration SQL + tracking record into a single D1 --file execution.
  # NOTE: D1 does not wrap --file calls in an implicit transaction; a failure
  # mid-way could leave tracking out of sync.
  TMPFILE="$TMPDIR_MIGRATE/$fname"
  # Strip drizzle-kit '--> statement-breakpoint' markers and normalize line endings;
  # these markers are not valid SQL and would cause D1 execution errors.
  sed 's/--> statement-breakpoint[[:space:]]*$//' "$file" | tr -d '\r' > "$TMPFILE"
  # Safety check: ensure no breakpoint markers remain
  if grep -q -- '--> statement-breakpoint' "$TMPFILE"; then
    echo "ERROR: Failed to strip all statement-breakpoint markers from $fname"
    echo "This may indicate unexpected formatting in the migration file."
    exit 1
  fi
  printf '\nINSERT INTO %s (filename) VALUES ('\''%s'\'');\n' "$TRACKING_TABLE" "$fname" >> "$TMPFILE"
  npx wrangler d1 execute "$DB_NAME" "$TARGET" --file="$TMPFILE"
  echo "    Done: $fname"
  PENDING=$((PENDING + 1))
done

if [[ $PENDING -eq 0 ]]; then
  echo "==> No pending migrations"
else
  echo "==> Applied $PENDING migration(s)"
fi
